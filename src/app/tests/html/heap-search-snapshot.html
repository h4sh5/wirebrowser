<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Heap Snapshot Testbed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; padding: 16px; }
    code, pre { background:#f6f8fa; padding: 8px 10px; border-radius: 8px; display:block; overflow:auto; }
    .ok { color: #0a7; }
    .warn { color:#b80; }
  </style>
</head>
<body>
  <h1>Heap Snapshot Testbed</h1>
  <p>This page instantiates a wide variety of data structures for testing <code>keyReg=/.*testKey.*/</code> and <code>valueReg=/.*testValue.*/</code>.</p>
  <p class="ok">Open DevTools â†’ Console to see a summary.</p>
  <pre id="summary"></pre>

  <script>

    // Classes -----------------------------------------------------------------
    class Class1 { constructor() { this.testKeyInClass1 = "some testValue here"; this.other = 42; } }
    class Class2 { constructor() { this.deep = { innerTestKey: { leaf: "testValue-leaf" } }; } }
    class NoMatch { constructor() { this.foo = "bar"; } }

    // Cyclic structure
    function makeCyclic() {
      const a = { name: "A" };
      const b = { name: "B", testKeyCycle: "testValue-cycle" };
      a.ref = b;
      b.ref = a;
      return a;
    }

    // Symbols -----------------------------------------------------------------
    const symTestKey = Symbol("testKeySymbol");
    const symPlain = Symbol("not-matching");

    // Map/Set -----------------------------------------------------------------
    const m = new Map();
    m.set("testKey-in-Map", "value with testValue inside");
    m.set({ nested: true }, { testKeyObj: "obj with testValue" });
    m.set("plainKey", "plainValue");

    const s = new Set();
    s.add("testValue-from-Set");
    s.add({ notMatching: true });

    // WeakMap/WeakSet (non-enumerable in snapshots)
    const wm = new WeakMap();
    const ws = new WeakSet();
    const wmKey = { id: 1 };
    wm.set(wmKey, { testKeyInWeak: "testValue-weak" });
    ws.add({ a: 1 });

    // Numeric types & specials ------------------------------------------------
    const smallInts = [1,2,4];                 // Packed SMI (FixedArray / (object elements))
    const floats = [1.1, 2.2, 3.3];            // FixedDoubleArray (values often not materialized)
    const mixed = [1, "x", 3];                 // forces boxing
    const bigints = [1n, 2n, 5555555555555555n];
    const typed = new Int32Array([10, 20, 30]);
    const onlyNumbersButHasString = [10, 20, "testValue", 40];

    // Complex array with multiple matches
    const arrComplex = [
      { testKey0: "aaa" },
      { ok: "bbb" },
      { key: "testValue" },           // value match only
      { testKeyHere: "something" },   // key match only
      "plain",
      31337,
      { deep: { very: { testKeyDeep: "deep testValue" } } }
    ];

    // Objects -----------------------------------------------------------------
    const objSimple = {
      testKeyTop: "top-level testValue",
      other: "nope",
    };

    const objNested = {
      a: { b: { c: { testKeyDeepObj: "value before", leaf: "not matching" } } },
      node: { name: "X", attrs: { 'data-testKey-attr': 'has testValue attr' } },
    };

    // Dynamic keys
    const dynamicKey = "prefix-testKey-suffix";
    const objDynamic = {
      [dynamicKey]: "value with a testValue inside",
      "no-match-key": "no-match-value",
      [symTestKey]: "symbol value with testValue",
      [symPlain]: "symbol value no match",
    };

    // Objects with classes
    const oWithClasses = {
      p1: new Class1(),
      p2: new Class2(),
      p3: "a string not matching",
      p4: new NoMatch(),
    };

    // Null/Undefined/Boolean
    const specialValues = {
      t: true,
      f: false,
      n: null,
      u: undefined,
      xxtestKey: "has testValue here"
    };

    // DOM Node
    const domStuff = {
      testKeyDom: "testValue in dom container",
      el: (() => {
        const div = document.createElement("div");
        div.setAttribute("data-testKey", "testValue in attribute");
        div.textContent = "hello";
        return div;
      })()
    };

    // Cyclic root
    const cyclicRoot = makeCyclic();


    // Other key-only / value-only cases
    const onlyKeyMatch = { testKeyOnly: 12345 };
    const onlyValueMatch = { foo: "zz-testValue-zz" };

    window.rts = {};
    window.rts.runtimeSearch = {
      rtProp: "rtVal"
    };
    window.rts.runtimeSearch2 = [
      {rtProp: "rtVal"}
    ];

  </script>
</body>
</html>
